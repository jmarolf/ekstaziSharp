// Copyright (c) 2017, Marko Vasic
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using EkstaziSharp.Util;
using System.Collections.Generic;
using System.Linq;

namespace EkstaziSharp.Instrumentation
{
    /// <summary>
    /// This class notifies DependencyMonitor about each class used during program execution
    /// by adding calls to DependencyMonitor in each instance constructor and on each static field access.
    /// </summary>
    public class InstanceProgramInstrumentator : ProgramInstrumentator
    {
        #region Private Fields

        /// <summary>
        /// Indicates whether method under instrumentation has been modified.
        /// </summary>
        private bool methodModified = false;

        /// <summary>
        /// Represents method currently under instrumentation.
        /// </summary>
        private MethodDefinition methodUnderInstrumentation;

        #endregion

        #region Constructors

        public InstanceProgramInstrumentator(ModuleDefinition moduleToInstrument, InstrumentatorParameters parameters)
            : base(moduleToInstrument, parameters)
        { }

        #endregion

        #region Private Methods

        private bool IsStaticFieldAccess(Instruction instruction)
        {
            return CecilExtensions.StaticAccessInstructions.Contains(instruction.OpCode);
        }

        private bool IsStaticMethodCall(Instruction instruction)
        {
            bool isCall = instruction.OpCode == OpCodes.Call;
            if (!isCall)
            {
                return false;
            }
            MethodReference callee = instruction.Operand as MethodReference;
            return !callee.HasThis;
        }

        private TypeReference GetStaticFieldAccessTarget(MethodDefinition method, Instruction staticFieldAccessInstruction)
        { 
            ILProcessor il = method.Body.GetILProcessor();
            FieldReference operand = staticFieldAccessInstruction.Operand as FieldReference;
            TypeReference declaringType = operand.DeclaringType;

            // In a case of types that are autogenerated out of lambda expressions
            // TypeReference does not give same name as TypeDefinition, and GetElementType
            // difference is that TypeReference includes generics parameters, e.g. T
            // For compatibility with Analysis phase, it is needed to use the other name
            return declaringType.GetElementType();
        }

        private TypeReference GetStaticMethodCallTarget(MethodDefinition method, Instruction staticMethodCallInstruction)
        {
            ILProcessor il = method.Body.GetILProcessor();
            MethodReference callee = staticMethodCallInstruction.Operand as MethodReference;
            // type containing method called used callInstruction
            TypeReference declaringType = callee.DeclaringType;
            // same reason as for GetStaticFieldAccessTarget
            return declaringType.GetElementType();
        }

        private bool WithinModuleUnderInstrumentation(TypeReference type)
        {
            return NamesOfModulesUnderInstrumentation.Contains(type.Scope.Name);
        }

        /// <summary>
        /// Returns a list of Instruction, Type pairs 
        /// that represent instrumentation point and coresponding type respectively.
        /// If instruction is null than whole method is a dependency
        /// </summary>
        private List<Tuple<Instruction, TypeReference>> GetInstrumentationPoints(MethodDefinition method)
        {
            List<Tuple<Instruction, TypeReference>> instrumentationPoints = new List<Tuple<Instruction, TypeReference>>();

            if (method.Name == CLRConstants.ConstructorName)
            {
                // TODO: can we use method.IsConstructor instead
                instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(null, method.DeclaringType));
            }

            foreach (var instruction in method.Body.Instructions)
            {
                if (IsStaticFieldAccess(instruction))
                {
                    TypeReference type = GetStaticFieldAccessTarget(method, instruction);
                    if (WithinModuleUnderInstrumentation(type))
                    {
                        instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(instruction, type));
                    }
                }
                else if (IsStaticMethodCall(instruction))
                {
                    TypeReference type = GetStaticMethodCallTarget(method, instruction);
                    if (WithinModuleUnderInstrumentation(type))
                    {
                        instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(instruction, type));
                    }
                }
            }

            return instrumentationPoints;
        }

        private void InstrumentAtPoints(MethodDefinition method, List<Tuple<Instruction, TypeReference>> instrumentationPoints)
        {
            if (instrumentationPoints.Count == 0)
            {
                return;
            }

            method.Body.SimplifyMacros();
            foreach (var pair in instrumentationPoints)
            {
                Instruction instruction = pair.Item1;
                TypeReference dependency = pair.Item2;
                if (instruction == null)
                {
                    InsertCallToDependencyMonitor(method, TMethod, dependency);
                }
                else
                {
                    InsertCallToDependencyMonitor(method, instruction, TMethod, dependency);
                }
            }
            method.Body.OptimizeMacros();
        }

        private void InstrumentAtMethodBeginning(MethodDefinition method, List<Tuple<Instruction, TypeReference>> instrumentationPoints)
        {
            if (instrumentationPoints.Count == 0)
            {
                return;
            }

            List<TypeReference> uniqueDependencies = new List<TypeReference>();
            HashSet<string> dependencyNames = new HashSet<string>();

            foreach (var tuple in instrumentationPoints)
            {
                TypeReference type = tuple.Item2;
                string dependencyName = $"{type.Module.Name}{type.FullName}";
                if (!dependencyNames.Contains(dependencyName))
                {
                    dependencyNames.Add(dependencyName);
                    uniqueDependencies.Add(type);
                }
            }

            foreach (var dependency in uniqueDependencies)
            {
                InsertCallToDependencyMonitor(method, TMethod, dependency);
            }
        }

        #endregion

        #region Public Methods

        public override void Instrument()
        {
            // TODO: Experiment with parallelizing following loops
            foreach (TypeDefinition type in moduleToInstrument.GetTypes(includeNestedTypes: true))
            {
                foreach (MethodDefinition method in type.Methods)
                {
                    if (!method.HasBody)
                    {
                        // TODO: check if you need to instrument constructors that have no body
                        // and in which cases constructors do not have body
                        continue;
                    }

                    List<Tuple<Instruction, TypeReference>> instrumentationPoints = GetInstrumentationPoints(method);

                    if (!parameters.InstrumentAtMethodBeginning)
                    {
                        InstrumentAtPoints(method, instrumentationPoints);
                    }
                    else
                    {
                        InstrumentAtMethodBeginning(method, instrumentationPoints);
                    }
                }
            }
        }

        #endregion
    }
}
